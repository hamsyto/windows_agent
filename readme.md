--- .env ---
IDLE_TIME=10 #секунд
IP_SERVER=10.10.0.70
#IP_SERVER=127.0.0.1
PORT_SERVER=8101
KEY=absf
AGENT_ID=0
TYPE=test
------------

--- компиляция как одна строка ---
g++ -fdiagnostics-color=always 
-static -static-libgcc -static-libstdc++ 
-Ilibs/lz4 libs\lz4\lz4.c libs\lz4\lz4hc.c libs\lz4\lz4frame.c libs\lz4\xxhash.c 
-DWIN32_LEAN_AND_MEAN -D_WIN32_WINNT=0x0A00 -DWINVER=0x0A00 
-fdiagnostics-color=always 
-O2 
        -g
        collector\fabric.cpp
        collector\Windows\collector.cpp
        collector\Windows\helpers.cpp
        connection\Windows\connection.cpp
     ?? connection\Windows\winConnection.cpp
        models\message.cpp
        models\settings.cpp
        transport\transport.cpp
        transport\chiper\chacha_handler.cpp
        transport\compressor\lz4_handler.cpp
        main.cpp
-lnetapi32 -lole32 -loleaut32 -lwbemuuid -liphlpapi -lbCrypt -lssl -lcrypto -lcrypt32 -lwsock32 -lgdi32 -lws2_32 
-o compiled\main.exe
--- -------------------------- ---

========================================================================
При сборке под Windows → компилируется только connectionWin.cpp.
При сборке под Linux → компилируется только connectionLin.cpp.

== щас делаю ==

== ========= ==
========================================================================


Формат штучки:
длина (сжатого и зашифрованного сообщения) | 12 байт nonce | сжатое и зашифрованное сообщение
tojson внести в структуры, чтобы они сами в json превращались

class collector()
class transport(settings)
class connection(settings (idle_time, ))


_____________________________________________________________
#         =      самое главное       =
#   Windows
   _WIN32 - макрос, определяемый препроцессором
   WSADATA - структура, заполняемая системой Windows (ws2_32.dll), реализующая Winsock API
   WSAStartup - инициализация Winsock

#   
<unordered_map>
   unordered_map - контейнер, реализующий ассоциативный массив (словарь) на основе хеш-таблицы.
   - каждый ключ может встречаться только один раз
   - неупорядоченный

   env_map.at() - исключение, если нет ключа

<fstream>
ifstream - чтение данных из файла
getline() - читает строку до '\n' (и не включает его)

<memory>
make_unique<>() - создаёт объукт в куче и возвращает указатель unique_ptr


virtuel - = 0 означает, что метод не имеет реализации в базовом классе — это чисто виртуальная функция.
- Ключевое слово override (необязательное, но рекомендуемое) говорит компилятору:
«Я намеренно переопределяю виртуальную функцию из базового класса».
#   
#   

=============================================================


легко делать (дома лучше):
- исправить все #include "файл.h"
- везде убрать float, заменить на uint (если проверка на -1, то int)
- сделать dll файл. он будет лежать рядом с exe (json.hpp нужно в dll превратить)


нужно сделать:
- проверку на правильность заполнения (если = 0 где его быть не может, значит неправильно заполнилось и нужно создать свой тип ошибки, вывести ошибку с помощью throw)

- сделать слушающий поток, чтобы если сервер пришлёт новый id - перерегистрироваться когда буду делать несколько потоков чтение - основной поток, отправка - фоновый


???
? usb может всё равно отправлять? а то необязателные данные, такое себе


- обработка ошибок ClearEnvFile()



+ LoadEnvSettings() теперь возвращает Settings
+ IConnection.h должен быть независим (изолирован) от ОС-специфичных функций
+ все классы должны получать Settings, тоесть классы получают все данные из вне и только определённую функцию выполняют




4. узнай что такое "this", и как он используется







нужно сделать:
1. все классы "глупые", выполняют не больше одной задачи (отпрвка, сбор данных, )
1. сделать слушающий поток, чтобы если сервер пришлёт новый id - перерегистрироваться  
    когда буду делать несколько потоков чтение - основной поток, отправка - фоновый
2. починить диски. usb добавить, когда их нет, просто не отправлять инфу о них.
3. доработка класса, чтобы работающие в нём функции стали чисто методами класса

0. (пока не надо) список, у mac-адресов может быть ip, а может и не быть. но если есть, нужно его (ip) прислать (вид: macадрес ipадрес (через пробел))
отдельная структура для флешок
0. ? чтобы при ошибке не переприсваивал id_addr. (при правильном отклбчении нен спамит. что-то не то load_env_settings получает)



я бы сделал:
- перед отправкой проверять id_file
- обёртка в commands.h для строк 60-64, 70-73
- команды от сервера (далёкое будущее)
- проверка каждой функции на заполнение структуры. переменная fail_fill
- запись всех ошиюок в файл (как с id_file)

======================================================================
сделано:
+ всё с маленькой буквы кроме IConnection.h
+ не  -commands_coll.cpp-  и  -winConnection.cpp-,  а  -helpers.cpp-
+ отправка длинны, сообщени 12 пустых байт (или бит, или не пустых а нешифрованных), сообщение
+ написать шифровальщик bytes
+ написать модуль сжималку json (zip). отправлять исходный размер json, потому что декомпрессия требует знания размера выходного буфера
JSON size: 659 | Compressed size: 529
ещё короче можно с 
    LZ4_compress_HC
    сокращая строки (не free а f)

+- Добавить отдельный тип сообщения IAmNotOK, если произошла какая-то критическая ошибка, например — ты не смогла собрать какие-то данные или что-то непонятное произошло. Например — нет разрешений на сбор данных каких-то, не смогла сохранить ID в файл. Если произошла ошибка, посылаешь подобный header, а в сообщении просто string "text" в котором описание ошибки
как-то надо всё пересобрать так, чтобы ты могла отловить ошибку через условный try catch

+ при ответе сервера закрывать соединение, ждать минуту и открывать соединение вновь (id сохранён)
+ сценарии. 2 метода (сценарий кто я и отправка данных)
    1. регистрация.
    2. послать данные.
+ пинг; (если ошибка, то в getAveragePing). функция которая 3-4 раза пингует сервер. вычиляет среднее и вычиляет значение в милисекундах.
+ обрезать float;
+ память не free, а usage
+ -static -static-libgcc -static-libstdc++
+ все данные с типом double, после запятой 2 числа, не больше
+ 4 функции в collector.cpp
+ поменять порты на 8000+
+   Надо сделать автоматическую регистрацию.
    1. Если agent_id не задан, то на сервер идёт сообщение,     что клиент хочет зарегистрироваться
        в формате json
        Payload пустой словарик, a тип сообщения whoami
        Ну, в header
        А agent_ID null
    2. Сервер отсылает ему его id.
    3. Клиент сохраняет у себя в памяти и в файле, и потом  отсылает его с каждым сообщением
+ system.sleep(settings.sleepInSeconds);
+ убрать вывод о нажатии enter чтобы переконектиться
+   если будет время / желание, сделай модуль, который  будет       инициализировать глобальную переменную   "SETTINGS", это     та самая наша структура с     настройками проекта.
    Там обязательно должны быть:
    1. int — время слипа между опросами;
    2. str — адрес сервера;
    3. int/str — порт сервера, на который будет закидываться       данные;
    
    Можешь сделать в корне проекта файл ".env" (именно такое       название), и попробовать сделать штуку, которая будет  читать этот файл, называется — файл окружения.
    Либо через settings.conf, будет читать conf файл
+ переименновать ser в setting
+ есть отправка длины сообщения


// си-стиль: (struct sockaddr*)&addr;
// си++ -стиль: reinterpret_cast<struct sockaddr*>(&addr);  static_cast,
// const_cast
// struct sockaddr* pAddr = reinterpret_cast<struct sockaddr*>(&addr);



1. инициализирует winsock
2. получаем порт и ip из .env
    .env должен быть, иначе некуда отправлять





реализация сценариев:
    string errorToString(Error e) {
        превратить ошибку в строку;
        return (string)error;
    }

    void registragte{
        string error = "";
        try{
            Hardware hardware = collect();
        } catch e {
            error = errorToString(e);
        }

        Начать соединение;
        if (error != "") {
            послать данные;
        } else {
            послать ошибку;
        }
        получить ID;
        try {
            сохраниить id в файл;
        } catch e {
            error = errorToString(e);
            отправить ошибку;
        }
        закрыть соединение;
    }


    void sendData(int id) {
        string error = "";
        try{
            Hardware hardware = collect();
        } catch e {
            error = errorToString(e);
        }

        Начать соединение;
        if (error != "") {
            послать данные;
        } else {
            послать ошибку;
        }
        закрыть соединение;

    }

    JSONDecodeError('Expecting value: line 1 column 1 (char 0)'): message = RawAgentMessage(ip='127.0.0.1', nonce=b'', buffer=b'\x00\x00\x02\xf3{"header":{"agent_id":0,"type":"whoami"},"payload":{"cpu":{"cores":16,"usage":0.1},"disks":[{"mount":"C:\\\\","number":0,"total":353955.0,"type":"NVME","used":280393.86},{"mount":"O:\\\\","number":0,"total":575737.0,"type":"NVME","used":360154.17}],"hardware":{"bios":"INSYDE Corp. - V1.26","cpu":"13th Gen Intel(R) Core(TM) i7-13620H","mac":["00:FF:14:AA:BE:33","00:15:5D:7A:43:0F","00:15:5D:4E:EB:63","0A:00:27:00:00:12","C4:3D:1A:CE:C0:62","C6:3D:1A:CE:C0:61","00:FF:23:25:D8:F7","C4:3D:1A:CE:C0:61","74:D4:DD:21:11:A7"],"video":["NVIDIA GeForce RTX 4050 Laptop GPU","Intel(R) UHD Graphics"]},"ping":0,"ram":{"total":16384.0,"used":13921.13},"system":{"domain":"WORKGROUP","hostname":"Eve-work","timestamp":1766400671,"version":"Windows 11"},"usb":[]}}')