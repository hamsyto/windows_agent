--- компиляция как одна строка---
g++ -fdiagnostics-color=always -g 
    main.cpp 
    collector\collectorr.cpp 
    collector\commands_coll.cpp  
-o compiled\main.exe -lws2_32 -lnetapi32

== щас делаю ==
доработка класса, чтобы работающие в нём функции стали чисто методами класса
===============

total 488386 | free 58366.4 | usege 430020
    476             56          419

проверка каждой функции на заполнение структуры. переменная fail_fill


tojson внести в структуры, чтобы они сами в json превращались


---

ошибка отправки

++ пинг; (если ошибка, то в getAveragePing)
++ обрезать float;
2. сделать dll файл. он будет лежать рядом с exe (json.hpp нужно в dll превратить)
3. память не free, а usage
4. сделать слушающий поток, чтобы если сервер пришлёт новый id - перерегистрироввться  
5. список, у mac-адресов может быть ip, а может и не быть. но если есть, нужно его (ip) прислать (вид: macадрес ipадрес (через пробел))
отдельная структура для флешок
?6. починить диски. usb добавить, когда их нет, просто не отправлять инфу о них
7. написать модуль сжималку json (zip)
8. написать шифровальщик bytes (что-то там в настройках указывается)
+ -static -static-libgcc -static-libstdc++

8. Добавить отдельный тип сообщения IAmNotOK, если произошла какая-то критическая ошибка, например — ты не смогла собрать какие-то данные или что-то непонятное произошло. Например — нет разрешений на сбор данных каких-то, не смогла сохранить ID в файл. Если произошла ошибка, посылаешь подобный header, а в сообщении просто string "text" в котором описание ошибки
как-то надо всё пересобрать так, чтобы ты могла отловить ошибку через условный try catch


нужно сделать:
- перед отправкой проверять id_file
- исправить чтение дисков (неправильно)
- пинги. функция которая 3-4 раза пингует сервер. вычиляет среднее и вычиляет значение в милисекундах.
- чтобы при ошибке не переприсваивал id_addr. (при правильном отклбчении нен спамит. что-то не то load_env_settings получает)
+ при ответе сервера закрывать соединение, ждать минуту и открывать соединение вновь (id сохранён)
- когда буду делать несколько потоков чтение - основной поток, отправка - фоновый
- написать сжималку json
- написать шифровальщик bytes

я бы сделал:
- обёртка в commands.h для строк 60-64, 70-73
- команды от сервера (далёкое будущее)
+ id_saved
- запись всех ошиюок в файл (как с id_file)



+ все данные с типом double, после запятой 2 числа, не больше

+ 4 функции в collector.cpp
+ поменять порты на 8000+
+   Надо сделать автоматическую регистрацию.
    1. Если agent_id не задан, то на сервер идёт сообщение,     что клиент хочет зарегистрироваться
        в формате json
        Payload пустой словарик, a тип сообщения whoami
        Ну, в header
        А agent_ID null
    2. Сервер отсылает ему его id.
    3. Клиент сохраняет у себя в памяти и в файле, и потом  отсылает его с каждым сообщением
+ system.sleep(settings.sleepInSeconds);
+ убрать вывод о нажатии enter чтобы переконектиться
+   если будет время / желание, сделай модуль, который  будет       инициализировать глобальную переменную   "SETTINGS", это     та самая наша структура с     настройками проекта.
    Там обязательно должны быть:
    1. int — время слипа между опросами;
    2. str — адрес сервера;
    3. int/str — порт сервера, на который будет закидываться       данные;
    
    Можешь сделать в корне проекта файл ".env" (именно такое       название), и попробовать сделать штуку, которая будет  читать этот файл, называется — файл окружения.
    Либо через settings.conf, будет читать conf файл
+ переименновать ser в setting

* есть отправка длины сообщения

функционал:
+ Регистрация по команде whoami


ip 10.10.0.70


   // си-стиль: (struct sockaddr*)&addr;
    // си++ -стиль: reinterpret_cast<struct sockaddr*>(&addr);  static_cast,
    // const_cast
    // struct sockaddr* pAddr = reinterpret_cast<struct sockaddr*>(&addr);



////////////////// RAM /////////////

- - отражает память видимую ОС - - 
    
// возвращает true при успехе
GlobalMemoryStatusEx() //  <windows.h>

MEMORYSTATUSEX.
    DWORDLONG ullTotalPhys;        // общий объём физической памяти (в байтах)
    DWORDLONG ullAvailPhys;        // доступно физической памяти
    // DWORDLONG — это unsigned __int64 (или uint64_t в терминах C++).

MEMORYSTATUSEX mem = {};
mem.dwLength = sizeof(mem);
if (GlobalMemoryStatusEx(&mem)) {
    ULONGLONG totalMB = mem.ullTotalPhys / (1024 * 1024);
}


  - - отражает реальное железо - - 
    
GetPhysicallyInstalledSystemMemory  //  <windows.h>

ULONGLONG memKB = 0;
if (GetPhysicallyInstalledSystemMemory(&memKB)) {
    ULONGLONG totalMB = memKB / 1024;
} 




1. инициализирует winsock
2. получаем порт и ip из .env
    .env должен быть, иначе некуда отправлять






сценарий 
2 метода (сценарий кто я и отправка данных)
1. регистрация
2. послать данные

string errorToString(Error e) {
    превратить ошибку в строку;
    return (string)error;
}

void registragte{
    string error = "";
    try{
        Hardware hardware = collect();
    } catch e {
        error = errorToString(e);
    }
    
    Начать соединение;
    if (error != "") {
        послать данные;
    } else {
        послать ошибку;
    }
    получить ID;
    try {
        сохраниить id в файл;
    } catch e {
        error = errorToString(e);
        отправить ошибку;
    }
    закрыть соединение;
}


void sendData(int id) {
    string error = "";
    try{
        Hardware hardware = collect();
    } catch e {
        error = errorToString(e);
    }
    
    Начать соединение;
    if (error != "") {
        послать данные;
    } else {
        послать ошибку;
    }
    закрыть соединение;

}