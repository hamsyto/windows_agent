--- компиляция как одна строка---
g++ -fdiagnostics-color=always -g 
    main.cpp 
    collector\collector.cpp 
    collector\commands_coll.cpp  
-o compiled\main.exe -lws2_32 -lnetapi32

== щас делаю ==

===============

tojson внести в структуры, чтобы они сами в json превращались
---

нужно сделать:
- перед отправкой проверять id_file
- исправить чтение дисков (неправильно)
- чтобы при ошибке не переприсваивал id_addr. (при правильном отклбчении нен спамит. что-то не то load_env_settings получает)
+ при ответе сервера закрывать соединение, ждать минуту и открывать соединение вновь (id сохранён)
- когда буду делать несколько потоков чтение - основной поток, отправка - фоновый
- написать сжималку json
- написать шифровальщик bytes


нужно сделать:
отправка длинны, сообщени 12 пустых байт (или бит, или не пустых а нешифрованных), сообщение
0. написать модуль сжималку json (zip). отправлять исходный размер json, потому что декомпрессия требует знания размера выходного буфера
JSON size: 659 | Compressed size: 529
ещё короче можно с 
    LZ4_compress_HC
    сокращая строки (не free а f)
1. написать шифровальщик bytes (что-то там в настройках указывается)
2. сделать слушающий поток, чтобы если сервер пришлёт новый id - перерегистрироввться  
3. сделать dll файл. он будет лежать рядом с exe (json.hpp нужно в dll превратить)
4. 
5. починить диски. usb добавить, когда их нет, просто не отправлять инфу о них.
    когда подключаю флешку он просто дублирует логические диски, физ диска 0. лажа :(
6. везде убрать float, заменить на uint
7. доработка класса, чтобы работающие в нём функции стали чисто методами класса
8. список, у mac-адресов может быть ip, а может и не быть. но если есть, нужно его (ip) прислать (вид: macадрес ipадрес (через пробел))
отдельная структура для флешок



я бы сделал:
- обёртка в commands.h для строк 60-64, 70-73
- команды от сервера (далёкое будущее)
+ id_saved
- проверка каждой функции на заполнение структуры. переменная fail_fill
- запись всех ошиюок в файл (как с id_file)

============================================================================
сделано:
+- Добавить отдельный тип сообщения IAmNotOK, если произошла какая-то критическая ошибка, например — ты не смогла собрать какие-то данные или что-то непонятное произошло. Например — нет разрешений на сбор данных каких-то, не смогла сохранить ID в файл. Если произошла ошибка, посылаешь подобный header, а в сообщении просто string "text" в котором описание ошибки
как-то надо всё пересобрать так, чтобы ты могла отловить ошибку через условный try catch

+ сценарии. 2 метода (сценарий кто я и отправка данных)
    1. регистрация.
    2. послать данные.
+ пинг; (если ошибка, то в getAveragePing). функция которая 3-4 раза пингует сервер. вычиляет среднее и вычиляет значение в милисекундах.
+ обрезать float;
+ память не free, а usage
+ -static -static-libgcc -static-libstdc++
+ все данные с типом double, после запятой 2 числа, не больше
+ 4 функции в collector.cpp
+ поменять порты на 8000+
+   Надо сделать автоматическую регистрацию.
    1. Если agent_id не задан, то на сервер идёт сообщение,     что клиент хочет зарегистрироваться
        в формате json
        Payload пустой словарик, a тип сообщения whoami
        Ну, в header
        А agent_ID null
    2. Сервер отсылает ему его id.
    3. Клиент сохраняет у себя в памяти и в файле, и потом  отсылает его с каждым сообщением
+ system.sleep(settings.sleepInSeconds);
+ убрать вывод о нажатии enter чтобы переконектиться
+   если будет время / желание, сделай модуль, который  будет       инициализировать глобальную переменную   "SETTINGS", это     та самая наша структура с     настройками проекта.
    Там обязательно должны быть:
    1. int — время слипа между опросами;
    2. str — адрес сервера;
    3. int/str — порт сервера, на который будет закидываться       данные;
    
    Можешь сделать в корне проекта файл ".env" (именно такое       название), и попробовать сделать штуку, которая будет  читать этот файл, называется — файл окружения.
    Либо через settings.conf, будет читать conf файл
+ переименновать ser в setting
+ есть отправка длины сообщения


// си-стиль: (struct sockaddr*)&addr;
// си++ -стиль: reinterpret_cast<struct sockaddr*>(&addr);  static_cast,
// const_cast
// struct sockaddr* pAddr = reinterpret_cast<struct sockaddr*>(&addr);



1. инициализирует winsock
2. получаем порт и ip из .env
    .env должен быть, иначе некуда отправлять





реализация сценариев:
    string errorToString(Error e) {
        превратить ошибку в строку;
        return (string)error;
    }

    void registragte{
        string error = "";
        try{
            Hardware hardware = collect();
        } catch e {
            error = errorToString(e);
        }

        Начать соединение;
        if (error != "") {
            послать данные;
        } else {
            послать ошибку;
        }
        получить ID;
        try {
            сохраниить id в файл;
        } catch e {
            error = errorToString(e);
            отправить ошибку;
        }
        закрыть соединение;
    }


    void sendData(int id) {
        string error = "";
        try{
            Hardware hardware = collect();
        } catch e {
            error = errorToString(e);
        }

        Начать соединение;
        if (error != "") {
            послать данные;
        } else {
            послать ошибку;
        }
        закрыть соединение;

    }