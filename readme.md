--- компиляция как одна строка---
g++ -fdiagnostics-color=always -g 
    main.cpp 
    collector\collectorr.cpp 
    collector\commands_coll.cpp  
-o compiled\main.exe -lws2_32 -lnetapi32

---



+? пинг; (если ошибка, то в getAveragePing)
++ обрезать float;
3. починить диски
4. написать сжималку json
5. написать шифровальщик bytes
+ -static -static-libgcc -static-libstdc++

7. Добавить отдельный тип сообщения IAmNotOK, если произошла какая-то критическая ошибка, например — ты не смогла собрать какие-то данные или что-то непонятное произошло. Например — нет разрешений на сбор данных каких-то, не смогла сохранить ID в файл. Если произошла ошибка, посылаешь подобный header, а в сообщении просто string "text" в котором описание ошибки
как-то надо всё пересобрать так, чтобы ты могла отловить ошибку через условный try catch


нужно сделать:
- перед отправкой проверять id_file
- исправить чтение дисков (неправильно)
- пинги. функция которая 3-4 раза пингует сервер. вычиляет среднее и вычиляет значение в милисекундах.
- чтобы при ошибке не переприсваивал id_addr. (при правильном отклбчении нен спамит. что-то не то load_env_settings получает)
- TODO
- при ответе сервера закрывать соединение, ждать минуту и открывать соединение вновь (id сохранён)
- когда буду делать несколько потоков чтение - основной поток, отправка - фоновый
- написать сжималку json
- написать шифровальщик bytes

я бы сделал:
- обёртка в commands.h для строк 60-64, 70-73
- команды от сервера (далёкое будущее)
- id_saved
- запись всех ошиюок в файл (как с id_file)



+ все данные с типом double, после запятой 2 числа, не больше

+ 4 функции в collector.cpp
+ поменять порты на 8000+
+   Надо сделать автоматическую регистрацию.
    1. Если agent_id не задан, то на сервер идёт сообщение,     что клиент хочет зарегистрироваться
        в формате json
        Payload пустой словарик, a тип сообщения whoami
        Ну, в header
        А agent_ID null
    2. Сервер отсылает ему его id.
    3. Клиент сохраняет у себя в памяти и в файле, и потом  отсылает его с каждым сообщением
+ system.sleep(settings.sleepInSeconds);
+ убрать вывод о нажатии enter чтобы переконектиться
+   если будет время / желание, сделай модуль, который  будет       инициализировать глобальную переменную   "SETTINGS", это     та самая наша структура с     настройками проекта.
    Там обязательно должны быть:
    1. int — время слипа между опросами;
    2. str — адрес сервера;
    3. int/str — порт сервера, на который будет закидываться       данные;
    
    Можешь сделать в корне проекта файл ".env" (именно такое       название), и попробовать сделать штуку, которая будет  читать этот файл, называется — файл окружения.
    Либо через settings.conf, будет читать conf файл
+ переименновать ser в setting

* есть отправка длины сообщения

функционал:
+ Регистрация по команде whoami


ip 10.10.0.70


   // си-стиль: (struct sockaddr*)&addr;
    // си++ -стиль: reinterpret_cast<struct sockaddr*>(&addr);  static_cast,
    // const_cast
    // struct sockaddr* pAddr = reinterpret_cast<struct sockaddr*>(&addr);



////////////////// RAM /////////////

- - отражает память видимую ОС - - 
    
// возвращает true при успехе
GlobalMemoryStatusEx() //  <windows.h>

MEMORYSTATUSEX.
    DWORDLONG ullTotalPhys;        // общий объём физической памяти (в байтах)
    DWORDLONG ullAvailPhys;        // доступно физической памяти
    // DWORDLONG — это unsigned __int64 (или uint64_t в терминах C++).

MEMORYSTATUSEX mem = {};
mem.dwLength = sizeof(mem);
if (GlobalMemoryStatusEx(&mem)) {
    ULONGLONG totalMB = mem.ullTotalPhys / (1024 * 1024);
}


  - - отражает реальное железо - - 
    
GetPhysicallyInstalledSystemMemory  //  <windows.h>

ULONGLONG memKB = 0;
if (GetPhysicallyInstalledSystemMemory(&memKB)) {
    ULONGLONG totalMB = memKB / 1024;
} 




1. инициализирует winsock
2. получаем порт и ip из .env
    .env должен быть, иначе некуда отправлять



